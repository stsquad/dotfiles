#!/bin/bash
#
# .bashrc_history
#
# Bash helpers for processing shell history
#

HISTDIR=$HOME/.cache/shell
if [ ! -d ${HISTDIR} ]; then
    mkdir -p ${HISTDIR}
fi

# append (as I use lots of shells)
shopt -s histappend

export HISTFILE=$HISTDIR/bash_${BASHPID}_history
export ALL_HISTORY=$HISTDIR/all_bash_history
export HISTCONTROL=ignoreboth:erasedups
export HISTIGNORE="&:rm *ls:[bf]g:exit:mpv"
export HISTSIZE=100000
export HISTFILESIZE=${HISTSIZE}

export PROMPT_COMMAND="history -a"


# Detect HH and set it up if we have it

HAVE_HH=$(find_alternatives "hh")

if [ -e ${HAVE_HH} ]; then
    export HH_CONFIG=keywords,hicolor
    HISTMSG="with hh"
    # if this is interactive shell, then bind hh to Ctrl-r
    if [[ $- =~ .*i.* ]]; then
        bind '"\C-r": "\C-a hh \C-j"'
    fi
else
    HISTMSG="plain"
fi

function combine_history
{
    (cd $HISTDIR;
     tmp_hist=$(mktemp /tmp/hist.XXXXXX);
     cat ${ALL_HISTORY} bash_* > $tmp_hist;
     sort -u $tmp_hist > ${ALL_HISTORY};
     rm $tmp_hist)
}

# Build up combined history and then remove current HISTFILE
# intended to be called on exiting the shell
function flush_history
{
    builtin history -a         # append current history to $HISTFILE
    combine_history
    rm ${HISTFILE}
}

# Flush history on exit
trap "{ flush_history; }" EXIT TERM

function h
{
    builtin history -a

    combine_history
    if [ -e ${HAVE_HH} ]; then
        HISTFILE=${ALL_HISTORY} hh "$@"
    else
        builtin history | ${GREP} "$@"
    fi
}

# Now setup history for this shell, we shall combine history
# and reload it into this file
combine_history
cp ${ALL_HISTORY} ${HISTFILE}
HISTMSG="${HISTMSG}, $(cat ${HISTFILE} | wc -l) entries"

alias .hist="source ${DOTFILES_DIR}/dotbash_hist"

echo "loading .bash_hist ($HISTMSG)"
