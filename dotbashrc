#
# Alexs .bashrc
# loaded by bash when any non-login shell started

#
# Source global definitions
#

#echo "Starting ajb's .bashrc $*"

#For debuging when we are interactive or non-interactive (tty)
#
#ENVLOG=~/tmp/env`date +%s`.log
#env > $ENVLOG
#echo "ARGS=$*" >> $ENVLOG

# If ssh is conecting to run a command it has no controlling TTY
INTERACTIVE=true
if [ "$SSH_CLIENT" != "" ]; then
  if [ "$SSH_TTY" == "" ]; then
      INTERACTIVE=false
  fi
fi

#if [ "$INTERACTIVE" == "true" ]; then
#  echo "Assuming interactive shell"
#fi


#if [ "$HOST" == "" ]; then
#    exec bash --norc
#fi

if [ -f /etc/bashrc ]; then
    source /etc/bashrc
fi

if [ -f /etc/bash.bashrc ]; then
    source /etc/bash.bashrc
fi

#############
# Aliases
#############

# I like a quick grep of history
alias h="history | grep"


#
# Some systems I use don't have a decent 'find' implentation so
#
FIND=`find --version 2>/dev/null`
if [  "${FIND:0:8}" == "GNU find" ]; then

    # Some nice find expressions
    FIND_BACKUPS=" -name '.#*' -o -name '#*#' -o -name '*\.~*.~' -o -path '*./CVS/*.'"
    FIND_CVS=" -path '*./CVS/.*' "
    FIND_CCODE="  -iname '*.[chS]' -or -iname '*.cc' "
    FIND_CHEAD=" -iname '*.h' "
        
    # Find files under here
    alias f='find . -iname'

    # and search code for stuff (when I figure out proper expansion and quuting I'll make this neater)
    
    #alias sc="find . -iname '*.[chS]' -or -iname '*.cc' -and -not \( -name '.#' -o -name '#*#' -o -name '*\.~*.~' -o -path '*./CVS/*.' \) -print0 | xargs -0 grep -H "

    alias sc="find . \( $FIND_CCODE \) -and -not \( $FIND_BACKUPS -o $FIND_CVS \) -print0 | xargs -0 grep -H"
    alias sh="find . -iname '*.h' -print0 | xargs -0 grep -H "
    alias sa="find . -xtype f -print0 | xargs -0 grep -H "
else
    #
    # Who knows how standard unix is, its not GNU so probably not
    #
    # Lets assume both find and grep are borken
    #

    # Find files under here
    alias f="find . -name"

    # and search code for stuff
    alias sc="find . -name '*.[chS]' -o  -name '*.cc' | xargs grep "
    alias sh="find . -name '*.h' | xargs grep "
    alias sa="find -L . -type f | xargs grep "
fi    

# create patches easily
export DIFFIGNORE="-X~/.diffignore "
alias mkpatch="diff -Naur $DIFFIGNORE "

# Make creating an isofs easy
alias mkcdimg="mkisofs -v -R -o ~/tmp/temp.iso "


######################
# Environent Variables
######################

# There is only one editor
export EDITOR=emacs

# set CFLAGS for debugging - autoconf usually picks it up.
export CFLAGS=-g3

# CVS exports
export CVS_RSH=ssh
export CVSEDITOR=emacs

# Setup history control - hard to get right, could do with
# bashcompletion as well. Just make sure I don't repeatedly delete stuff

# append (as I use lots of shells)
shopt -s histappend

export HISTCONTROL=ignoredups
export HISTIGNORE="rm*"
export HISTFILESIZE=10000


#
# Gentoo Related Macros
#
# These are various tools for manipulating a local
# portage structure (which can be part of an overlay)
#
# These functions allow you to list, clone, delete and diff ebuilds
#

LOCAL_PORTAGE=$HOME/portage
MASTER_PORTAGE=/usr/portage

alias ls_le="find $LOCAL_PORTAGE -xtype d -mindepth 2 -maxdepth 2 | sed s#$LOCAL_PORTAGE##"
alias ls_me="find $MASTER_PORTAGE -xtype d -mindepth 2 -maxdepth 2 | sed s#$MASTER_PORTAGE##"

#
# guess_ebuild
#
# Take a string, possibly partial and match it a proper group/ebuild
#
function guess_ebuild()
{
    tmp=`ls_me | grep $1`
    group=`echo $tmp | perl -ne 'm#/([^/]*)#; print "$1"'`
    ebuild=`echo $tmp | perl -ne 'm#/([^/]*)/(\w*)#; print "$2"'`
}


#
# diff ebuild
#
# Do a diff for a given ebuild
#
function diff_ebuild()
{
    result=0
    
    if [ "$1" ]
    then
	guess_ebuild $1
	if [[ "$group" && "$ebuild" ]]
	then 
	    diff -ub $MASTER_PORTAGE/$group/$ebuild $LOCAL_PORTAGE/$group/$ebuild
	fi
    else
	for ebuild in `ls_le`
	do
	  diff -ub $MASTER_PORTAGE/$ebuild $LOCAL_PORTAGE/$ebuild
	done
    fi
}

#
# Clone an ebuild from the master tree into the local tree
#
#
function clone_ebuild()
{
    if [ "$1" ]
    then
	guess_ebuild $1
	if [[ "$group" && "$ebuild" ]]
	then 
	    echo "Cloning ebuild $group/$ebuild"
	    mkdir -p $LOCAL_PORTAGE/$group
	    cp -aP $MASTER_PORTAGE/$group/$ebuild $LOCAL_PORTAGE/$group/
	else
	    echo "$1 not in  Master Portage"
	fi
    else
        echo "No ebuild specified"
    fi
}


#
# Clean ebuilds
#
# Delete untouched ebuilds from local portage
#
function clean_ebuilds()
{
    for ebuild in `ls_le`
    do
      result=`diff -br --brief $MASTER_PORTAGE/$ebuild $LOCAL_PORTAGE/$ebuild`
      if [ "x$result" == "x" ]
      then
	  echo "Removing local copy of $ebuild"
	  rm -rf $LOCAL_PORTAGE/$ebuild
      fi
    done
}

# Setup the prompt to show who I am and on what machine
export PS1="\A \u@\h [\W] >"

# GNU systems usually use less by default for
# man pages, however not all unix-a-likes do
export PAGER=less

########################
# Miscelaneous Stuff
########################
# I want core-dumps dammit
ulimit -S -c unlimited

#
# Now source any local bashrc's which can overide stuff
# or add stuff relevant to the system I am on
#
# We only want this for interactive shells as remote
# noise just gets in the way.

if [ "$INTERACTIVE" == "true" ]; then

  # Generic local configs for work and stuff
  if [ -f $HOME/.bashrc_local ]; then
    echo "loading .bashrc_local"
    source $HOME/.bashrc_local
  fi

  # Gentoo Stuff
  if [ -f $HOME/.bashrc_gentoo ]; then
    if [ -d /usr/portage ];
    then
	echo "loading .bashrc_gentoo"
	source $HOME/.bashrc_gentoo
    fi
  fi

  
fi
  
