#!/bin/bash
#
# Alexs .bashrc
# loaded by bash when any non-login shell started

#
# Source global definitions
#

#echo "Starting ajb's .bashrc $*"

#For debuging when we are interactive or non-interactive (tty)
#
#ENVLOG=~/tmp/env`date +%s`.log
#env > $ENVLOG
#echo "ARGS=$*" >> $ENVLOG
#PID=$$
#echo "PID=$PID"  >> $ENVLOG
#cat /proc/$PID/cmdline >> $ENVLOG
#echo "pstree" >> $ENVLOG
#pstree -p >> $ENVLOG

# If ssh is conecting to run a command it has no controlling TTY
INTERACTIVE=true
if [ "$SSH_CLIENT" != "" ]; then
  if [ "$SSH_TTY" == "" ]; then
      INTERACTIVE=false
  fi
fi

#if [ "$INTERACTIVE" == "true" ]; then
#  echo "Assuming interactive shell"
#fi

if [ -f /etc/bashrc ]; then
    source /etc/bashrc
fi

if [ -f /etc/bash.bashrc ]; then
    source /etc/bash.bashrc
fi

#######################################################################
# Terminal Setup 
#
# via http://github.com/ciaranm/dotfiles-ciaranm/tree/master/bashrc
#
# The Apple Terminal doesn't seem to handle 256 colours very well so we
# limit it to a 16 colour display
#######################################################################

case "${TERM}" in
    xterm*)
#        export TERM=xterm-256color
	case "${TERM_PROGRAM}" in
	    Apple_Terminal)
		cache_term_colours=16
		;;
	    *)
		cache_term_colours=256
		;;
	esac
        ;;
    screen)
        cache_term_colours=256
        ;;
    dumb)
        cache_term_colours=2
        ;;
    *)
        cache_term_colours=16
        ;;
esac
 
case "${cache_term_colours}" in
    256)
        cache_colour_l_blue='\033[38;5;33m'
        cache_colour_d_blue='\033[38;5;21m'
        cache_colour_m_purp='\033[38;5;69m'
        cache_colour_l_yell='\033[38;5;229m'
        cache_colour_m_yell='\033[38;5;227m'
        cache_colour_m_gren='\033[38;5;35m'
        cache_colour_m_grey='\033[38;5;245m'
        cache_colour_m_orng='\033[38;5;208m'
        cache_colour_l_pink='\033[38;5;206m'
        cache_colour_m_teal='\033[38;5;38m'
        cache_colour_m_brwn='\033[38;5;130m'
        cache_colour_end='\033[0;0m'
        ;;
    16)
        cache_colour_l_blue='\033[1;34m'
        cache_colour_d_blue='\033[0;32m'
        cache_colour_m_purp='\033[0;35m'
        cache_colour_l_yell='\033[1;33m'
        cache_colour_m_yell='\033[0;33m'
        cache_colour_m_gren='\033[0;32m'
        cache_colour_m_grey='\033[0;37m'
        cache_colour_m_orng='\033[1;31m'
        cache_colour_l_pink='\033[1;35m'
        cache_colour_m_teal='\033[0;36m'
        cache_colour_m_brwn='\033[0;31m'
        cache_colour_end='\033[0;0m'
        ;;
    *)
        eval unset ${!cache_colour_*}
        ;;
esac

#############
# Aliases
#############

# I like a quick grep of history
alias h="history | grep"

# Find a given export in history
function he
{
    if [ "$1" ]
    then
       history | grep -E "^ [0-9]+  export $1" | uniq -s 6 -u
    fi
}

# Search through a list of alternative binaries, returning the first match
function find_alternatives ()
{
    for arg in "$@"
    do
      # --skip-alias only works with GNU which
      # file=`which --skip-alias $arg 2> /dev/null`
      file=`which $arg 2> /dev/null`
      if [ -x "$file" ]; then
	  echo "$file"
	  return
      fi
    done
}


#
# Lets see if we have a decent "grep"
#
GREP=$(find_alternatives "ggrep" "grep")
alias grep="$GREP"

#
# Look for a decent diff
#
DIFF=$(find_alternatives "gdiff" "diff")
alias diff="$DIFF"


#
# Some systems I use don't have a decent 'find' implentation so
#

# Lets look for gfind first (The GNU find on Solaris)
FIND=$(find_alternatives "gfind" "find")
alias find="$FIND"

FIND_VERSION=`find --version 2>/dev/null`
if [  "${FIND_VERSION:0:8}" == "GNU find" ]; then

    # Some nice find expressions
    FIND_BACKUPS=" -name '.#*' -o -name '#*#' -o -name '*\.~*.~' -o -path '*./CVS/*.'"
    FIND_CVS=" -path '*./CVS/.*' "
    FIND_CCODE="  -iname '*.[chS]' -or -iname '*.cc' "
    FIND_CHEAD=" -iname '*.h' "
        
    # and search code for stuff (when I figure out proper expansion and quuting I'll make this neater)
    
    #alias sc="find . -iname '*.[chS]' -or -iname '*.cc' -and -not \( -name '.#' -o -name '#*#' -o -name '*\.~*.~' -o -path '*./CVS/*.' \) -print0 | xargs -0 grep -H "

    alias f="$FIND -iname"
    alias sc="$FIND . \( $FIND_CCODE \) -and -not \( $FIND_BACKUPS -o $FIND_CVS \) -print0 | xargs -0 grep -H"
#    alias sh="find . -iname '*.h' -print0 | xargs -0 grep -H "
    alias sa="$FIND . -xtype f -print0 | xargs -0 grep -H "
else
    #
    # Who knows how standard unix is, its not GNU so probably not
    #
    # Lets assume both find and grep are borken
    #

    # Find files under here
    alias f="$FIND . -name"

    # and search code for stuff
    alias sc="$FIND . -name '*.[chS]' -o  -name '*.cc' | xargs grep "
#    alias sh="find . -name '*.h' | xargs grep "
    alias sa="$FIND -L . -type f | xargs grep "
fi    


# create patches easily
export DIFFIGNORE="-X~/.diffignore "
alias mkpatch="diff -Naur $DIFFIGNORE "

# Make creating an isofs easy
alias mkcdimg="mkisofs -v -R -o ~/tmp/temp.iso "


######################
# Environent Variables
######################

# There is only one editor (although I can get to it in different ways)
#
# Anything that uses EDITOR/VISUAL probably wants to call emacsclient if it can.
# The only other wrinkle being that in none X mode I'll be wanting to use multi-tty
# support if it exists. Let's see if we can make sense of all that.

# Only do this if the server is running
if [ -e "${HOME}/.emacs_server" -o -e "/tmp/emacs${UID}/server" ]; then
    if [[ "$DISPLAY" == "" ]]; then
        # Can we use muti-tty?
	emacsclient --help | grep "\-\-tty" > /dev/null
	if [[ "$?" == "0" ]]; then
    	    # Thats a yes
	    EMACS_CMD="emacsclient --tty "
	else
	    # Hmmm, opening in another pane would be a pain?
	    EMACS_CMD="emacs -nw "
	fi
    else
	# For X the focusing of the new frame is problem for emacs, I should see it
	EMACS_CMD="emacsclient -c"
    fi
else
    # If we have no server running lets just call emacs
    EMACS_CMD="emacs "
fi

export EDITOR=${EMACS_CMD}
export VISUAL=${EMACS_CMD}
# alternate is always straight emacs incase the server died
export ALTERNATE_EDITOR=emacs

# shortcut
alias ec="${EMACS_CMD}"

# set CFLAGS for debugging - autoconf usually picks it up.
export CFLAGS=-g3

# CVS exports
export CVS_RSH=ssh
export CVSEDITOR=ec

# Setup history control - hard to get right, could do with
# bashcompletion as well. Just make sure I don't repeatedly delete stuff

# append (as I use lots of shells)
shopt -s histappend

# Dump history to the file each prompt
PROMPT_COMMAND='history -a'

export HISTCONTROL=ignoredups
export HISTIGNORE="rm*"
export HISTFILESIZE=10000

# I have stuff in ~/bin
if [ -d $HOME/bin ]; then
  export PATH=~/bin:$PATH
fi

# GNU systems usually use less by default for
# man pages, however not all unix-a-likes do
export PAGER=less

#
# GIT Stuff
#
export GIT_AUTHOR_NAME="Alex Bennee"
export GIT_AUTHOR_EMAIL="alex@bennee.com"
export GIT_COMMITTER_NAME="Alex Bennee"

# Until I retrain my brain
alias git-diff='git diff'
alias git-commit='git commit'
alias git-log='git log'
alias git-push='git push'

#
# locales
#

export LANG=en_GB
export LANGUAGE=en_GB
export LC_ALL=C

#
# PATH hackage
#
# Not installing everything I like to quickly setup my local LD_LIBRARY_PATH and PATH
# for non-root installs and resting. This will break if you attempt to do things like
# suid in code your testing as LD_LIBRARY_PATH isn't usually exported to suid binaries
# for obvious security reasons.
#

# Save the PATH/LD_LIBRARY_PATH
export ORIG_PATH=$PATH
export ORIG_LD_PATH=$LD_LIBRARY_PATH

function clear_world
{
    export PATH=$ORIG_PATH
    export LD_LIBRARY_PATH=$ORIG_LD_PATH
    echo "Reset to"
    echo "PATH=$PATH"
    echo "LD_LIBRARY_PATH=$LD_LIBRARY_PATH"
}

alias cw="clear_world"

function switch_world
{
    # Save the old state
    OLD_WORLD_ROOT=$CURRENT_WORLD_ROOT
    OLD_WORLD_BIN=$CURRENT_WORLD_BIN
    OLD_WORLD_LIB=$CURRENT_WORLD_LIB
    OLD_WORLD_SRC=$CURRENT_WORLD_SRC

    if [ "$1" ]
    then
	# Reset
	if [ "$1" = "-" ]
	then
	    PATH=$ORIG_PATH
	    LD_LIBRARY_PATH=$ORIG_LD_PATH
	    echo "PATH=$PATH"
	    echo "LD_LIBRARY_PATH=$LD_LIBRARY_PATH"
	    return
	elif [ "$1" = "." ]
	then
	    CURRENT_WORLD_ROOT=`pwd`
	else
	    CURRENT_WORLD_ROOT=$1
	fi
    else
	CURRENT_WORLD_ROOT=`pwd`
    fi

    # Check the paths are valid
    CURRENT_WORLD_BIN=${CURRENT_WORLD_ROOT}/install/bin
    if [ -d "$CURRENT_WORLD_BIN" ]
    then
	echo "Setting CURRENT_WORLD_BIN=$CURRENT_WORLD_BIN"
	export CURRENT_WORLD_BIN
	export PATH=$CURRENT_WORLD_BIN:$ORIG_PATH
    else
	echo "No directory at $CURRENT_WORLD_BIN, giving up"
	CURRENT_WORLD_ROOT=$OLD_WORLD_ROOT
	CURRENT_WORLD_BIN=$OLD_WORLD_BIN
	return
    fi

    # The lib path needs to point at the libs we use, we overide LD_LIBRARY_PATH
    # so the correct libs are loaded. This *will not work* with suid binaries as it opens
    # a massive security hole

    CURRENT_WORLD_LIB=${CURRENT_WORLD_ROOT}/install/lib
    if [ -d "$CURRENT_WORLD_LIB" ]
    then
	echo "Setting CURRENT_WORLD_LIB=$CURRENT_WORLD_LIB"
	export CURRENT_WORLD_LIB
	export LD_LIBRARY_PATH=$CURRENT_WORLD_LIB:$ORIG_LD_PATH
    else
	echo "No directory at $CURRENT_WORLD_LIB, giving up"
	CURRENT_WORLD_ROOT=$OLD_WORLD_ROOT
	CURRENT_WORLD_BIN=$OLD_WORLD_BIN
	CURRENT_WORLD_LIB=$OLD_WORLD_LIB
	clear_world
	return
    fi

}

alias sw="switch_world"


#
# surfraw, command line browser control
# http://surfraw.alioth.debian.org/
#
SURFRAW=$(find_alternatives "surfraw")
if [[ -f $SURFRAW ]]; then
    alias wiki="$SURFRAW wikipedia "
    alias google="$SURFRAW google "
    alias imdb="$SURFRAW imdb "
    alias code="$SURFRAW codesearch"
    alias jspcode="$SURFRAW codesearch lang:jsp"
    alias javacode="$SURFRAW codesearch lang:java"
    alias pycode="$SURFRAW codesearch lang:python"
fi



########################
# PS Setup
########################

function ps_scm_f() {
    local s=
    if [[ -d ".svn" ]] ; then
        local r=$(svn info | sed -n -e '/^Revision: \([0-9]*\).*$/s//\1/p' )
        s="(r$r$(svn status | grep -q -v '^?' && echo -n "*" ))"
    else
        local d=$(git rev-parse --git-dir 2>/dev/null ) b= r= a= c=
        if [[ -n "${d}" ]] ; then
            if [[ -d "${d}/../.dotest" ]] ; then
                if [[ -f "${d}/../.dotest/rebase" ]] ; then
                    r="rebase"
                elif [[ -f "${d}/../.dotest/applying" ]] ; then
                    r="am"
                else
                    r="???"
                fi
                b=$(git symbolic-ref HEAD 2>/dev/null )
            elif [[ -f "${d}/.dotest-merge/interactive" ]] ; then
                r="rebase-i"
                b=$(<${d}/.dotest-merge/head-name)
            elif [[ -d "${d}/../.dotest-merge" ]] ; then
                r="rebase-m"
                b=$(<${d}/.dotest-merge/head-name)
            elif [[ -f "${d}/MERGE_HEAD" ]] ; then
                r="merge"
                b=$(git symbolic-ref HEAD 2>/dev/null )
            elif [[ -f "${d}/BISECT_LOG" ]] ; then
                r="bisect"
                b=$(git symbolic-ref HEAD 2>/dev/null )"???"
            else
                r=""
                b=$(git symbolic-ref HEAD 2>/dev/null )
            fi
 
            if git status | grep -q '^# Changed but not updated:' ; then
                a="${a}*"
            fi
 
            if git status | grep -q '^# Changes to be committed:' ; then
                a="${a}+"
            fi
 
            if git status | grep -q '^# Untracked files:' ; then
                a="${a}?"
            fi
 
            b=${b#refs/heads/}
            b=${b// }
            [[ -n "${b}" ]] && c="$(git config "branch.${b}.remote" 2>/dev/null )"
            [[ -n "${r}${b}${c}${a}" ]] && s="(${r:+${r}:}${b}${c:+@${c}}${a:+ ${a}})"
        fi
    fi
    echo -n "$s"
}

cache_colour_scm=${cache_colour_m_orng}
ps_scm="\[${cache_colour_scm}\]\$(ps_scm_f)\[${cache_colour_end}\]"

# Hangover from the Transitive days, but I do like seeing my processor
PROC=`uname -m`
if [ "$PROC" == "unknown" ]; then
  PROC=`uname -m`
fi
ps_proc="\[${cache_colour_m_purp}\]$PROC\[${cache_colour_end}\]"


# Setup the prompt to show who I am and on what machine, what processor and my SCM state
export PS1="\A \u@\h/${ps_proc} [\W] >"


# We want to extract the screen session name (if it exisits) from STY
function ps_xterm_f()
{
    session_name=${STY/*./}
    if [ $session_name ]; then
	session_name="${session_name}@`hostname`"
    else
	session_name="`pwd`@`hostname`"
    fi
    echo -n -e "\e]2;${session_name}\a"
}

if [[ "$TERM" == "xterm" || "$TERM" == "screen" ]]; then
    # Too prevent confusion about line lengths we append this to the PROMPT_COMMAND
    export PROMPT_COMMAND="$PROMPT_COMMAND; ps_xterm_f"
fi

# Screen can loose connections to the root ssh-agent. Either we could create and agent for
# every screen or just try and dink it out again.

find_ssh_agent()
{
    KEYS=`ssh-add -l`
    
}

########################
# Miscelaneous Stuff
########################
# I want core-dumps dammit
ulimit -S -c unlimited

#
# Now source any local bashrc's which can overide stuff
# or add stuff relevant to the system I am on
#
# We only want this for interactive shells as remote
# noise just gets in the way.

if [ "$INTERACTIVE" == "true" ]; then

  # If we have apt on this system I'll want some
  # debian like shortcuts
  APT=$(find_alternatives "apt")
  if [[ -f $APT && -f $HOME/.bashrc_apt ]]; then
    echo "loading .bashrc_apt"
    source $HOME/.bashrc_apt
  fi
  unset APT

  # Gentoo Stuff
  EMERGE=$(find_alternatives "emerge")
  if [[ -f $EMERGE && -f $HOME/.bashrc_gentoo ]]; then
    if [ -d /usr/portage ]; then
      echo "loading .bashrc_gentoo"
      source $HOME/.bashrc_gentoo
    fi
  fi
  unset EMERGE

  # KVM Stuff
  KVM=$(find_alternatives "kvm")
  if [[ -f $KVM && -f $HOME/.bashrc_kvm ]]; then
    echo "loading .bashrc_kvm"
    source $HOME/.bashrc_kvm
  fi
  unset KVM
  
  # Any machine specific stuff
  HOST_BASHRC="$HOME/.bashrc_`hostname`"
  if [ -f $HOST_BASHRC ]; then
    echo "loading .bashrc_`hostname`"
    source $HOST_BASHRC
  fi

  # Screen Tweaks
  SCREEN=$(find_alternatives "screen")
  if [[ -f $SCREEN && -f $HOME/.bashrc_screen ]]; then
      echo "loading .bashrc_screen"
      source $HOME/.bashrc_screen
  fi
  
  # Generic local configs for work and stuff
  if [ -f $HOME/.bashrc_local ]; then
    echo "loading .bashrc_local"
    source $HOME/.bashrc_local
  fi


fi
