#!/bin/bash
#
# Alexs .bash_profile
# Loaded by bash when any non-login shell started
#
# Normal environment variable tweaks should be hidden away in
# the .bashrc (assuming they don't mess with ssh/tramp stuff)
#

set +x
#
# Source global definitions
#

#echo "Starting ajb's .bashrc $*"
#set -x

#For debuging when we are interactive or non-interactive (tty)
#
#ENVLOG=~/tmp/env`date +%s`.log
#env > $ENVLOG
#echo "ARGS=$*" >> $ENVLOG
#PID=$$
#echo "PID=$PID"  >> $ENVLOG
#cat /proc/$PID/cmdline >> $ENVLOG
#echo "pstree" >> $ENVLOG
#pstree -p >> $ENVLOG

if [ -f /etc/bashrc ]; then
    source /etc/bashrc
fi

if [ -f /etc/bash.bashrc ]; then
    source /etc/bash.bashrc
fi

if [ -f $HOME/.bashrc ]; then
    source $HOME/.bashrc
fi

#############
# Aliases
#############

# I like a quick grep of history
alias h="history | grep"

# Find a given export in history
function he
{
    if [ "$1" ]
    then
       history | grep -E "^ [0-9]+  export $1" | uniq -s 6 -u
    fi
}

# Search through a list of alternative binaries, returning the first match
function find_alternatives ()
{
    for arg in "$@"
    do
      # --skip-alias only works with GNU which
      # file=`which --skip-alias $arg 2> /dev/null`
      file=`which $arg 2> /dev/null`
      if [ -x "$file" ]; then
	  echo "$file"
	  return
      fi
    done
    echo "/alternative/not/found"
}

# Search though a list of directories, returning first match
function find_directories ()
{
    for d in "$@"
    do
      if [ -d "$d" ]; then
	  echo "$d"
	  return
      fi
    done
    echo "/alternative/not/found"
}

#
# Lets see if we have a decent "grep"
#
GREP=$(find_alternatives "ack-grep" "ggrep" "grep" "/bin/grep")
alias grep="$GREP"

#
# Look for a decent diff
#
DIFF=$(find_alternatives "gdiff" "diff")
alias diff="$DIFF"

#
# Some systems I use don't have a decent 'find' implentation so
#

# Lets look for gfind first (The GNU find on Solaris)
FIND=$(find_alternatives "gfind" "find")
alias find="$FIND"

FIND_VERSION=`find --version 2>/dev/null`
if [  "${FIND_VERSION:0:8}" == "GNU find" ]; then

    # Some nice find expressions
    FIND_BACKUPS=" -name '.#*' -o -name '#*#' -o -name '*\.~*.~' -o -path '*./CVS/*.'"
    FIND_CVS=" -path '*./CVS/.*' "
    FIND_CCODE="  -iname '*.[chS]' -or -iname '*.cc' "
    FIND_CHEAD=" -iname '*.h' "
        
    # and search code for stuff (when I figure out proper expansion and quuting I'll make this neater)
    
    #alias sc="find . -iname '*.[chS]' -or -iname '*.cc' -and -not \( -name '.#' -o -name '#*#' -o -name '*\.~*.~' -o -path '*./CVS/*.' \) -print0 | xargs -0 grep -H "

    alias f="$FIND -iname"
    alias sc="$FIND . \( $FIND_CCODE \) -and -not \( $FIND_BACKUPS -o $FIND_CVS \) -print0 | xargs -0 grep -H"
#    alias sh="find . -iname '*.h' -print0 | xargs -0 grep -H "
    alias sa="$FIND . -xtype f -print0 | xargs -0 grep -H "
else
    #
    # Who knows how standard unix is, its not GNU so probably not
    #
    # Lets assume both find and grep are borken
    #

    # Find files under here
    alias f="$FIND . -name"

    # and search code for stuff
    alias sc="$FIND . -name '*.[chS]' -o  -name '*.cc' | xargs grep "
#    alias sh="find . -name '*.h' | xargs grep "
    alias sa="$FIND -L . -type f | xargs grep "
fi    

# Find a decent browser
BROWSER=$(find_alternatives "chromium-browser" "google-chrome" "chrome" "firefox-4.0" "firefox" "mozilla")

######################
# Environent Variables
######################

# One editor
export EDITOR=emacs

# set CFLAGS for debugging - autoconf usually picks it up.
#export CFLAGS=-g3

# CVS exports
export CVS_RSH=ssh
export CVSEDITOR=ec

# Setup history control - hard to get right, could do with
# bashcompletion as well. Just make sure I don't repeatedly delete stuff
# See: http://unix.stackexchange.com/questions/1288/preserve-bash-history-in-multiple-terminal-windows#3055135

# append (as I use lots of shells)
shopt -s histappend

export HISTCONTROL=ignoredups:erasedups
#export HISTIGNORE="rm *"
export HISTIGNORE="&:rm *ls:[bf]g:exit"
export HISTSIZE=100000
export HISTFILESIZE=${HISTSIZE}

history() {
  _bash_history_sync
  builtin history "$@"
}

_bash_history_sync() {
  builtin history -a         #1
  HISTFILESIZE=$HISTSIZE     #2
  builtin history -c         #3
  builtin history -r         #4
}

# fixup 
export PROMPT_COMMAND=_bash_history_sync

# GNU systems usually use less by default for
# man pages, however not all unix-a-likes do
export PAGER=less

#
# PATH hackage
#
# Not installing everything I like to quickly setup my local LD_LIBRARY_PATH and PATH
# for non-root installs and resting. This will break if you attempt to do things like
# suid in code your testing as LD_LIBRARY_PATH isn't usually exported to suid binaries
# for obvious security reasons.
#

# Save the PATH/LD_LIBRARY_PATH
export ORIG_PATH=$PATH
export ORIG_LD_PATH=$LD_LIBRARY_PATH

function clear_world
{
    export PATH=$ORIG_PATH
    export LD_LIBRARY_PATH=$ORIG_LD_PATH
    echo "Reset to"
    echo "PATH=$PATH"
    echo "LD_LIBRARY_PATH=$LD_LIBRARY_PATH"
}

alias cw="clear_world"

# Add a ../install world into our path, overwriting any PATH/LD_LIBRARY_PATH fiddles
function switch_world
{
    # Save the old state
    OLD_WORLD_ROOT=$CURRENT_WORLD_ROOT
    OLD_WORLD_BIN=$CURRENT_WORLD_BIN
    OLD_WORLD_LIB=$CURRENT_WORLD_LIB
    OLD_WORLD_SRC=$CURRENT_WORLD_SRC

    if [ "$1" ]
    then
	# Reset
	if [ "$1" = "-" ]
	then
	    PATH=$ORIG_PATH
	    LD_LIBRARY_PATH=$ORIG_LD_PATH
	    echo "PATH=$PATH"
	    echo "LD_LIBRARY_PATH=$LD_LIBRARY_PATH"
	    return
	elif [ "$1" = "." ]
	then
	    CURRENT_WORLD_ROOT=`pwd`
	else
	    CURRENT_WORLD_ROOT=$1
	fi
    else
	CURRENT_WORLD_ROOT=`pwd`
    fi

    # Check the paths are valid
    CURRENT_WORLD_BIN=${CURRENT_WORLD_ROOT}/install/bin
    if [ -d "$CURRENT_WORLD_BIN" ]
    then
	echo "Setting CURRENT_WORLD_BIN=$CURRENT_WORLD_BIN"
	export CURRENT_WORLD_BIN
	export PATH=$CURRENT_WORLD_BIN:$ORIG_PATH
    else
	echo "No directory at $CURRENT_WORLD_BIN, giving up"
	CURRENT_WORLD_ROOT=$OLD_WORLD_ROOT
	CURRENT_WORLD_BIN=$OLD_WORLD_BIN
	return
    fi

    # The lib path needs to point at the libs we use, we overide LD_LIBRARY_PATH
    # so the correct libs are loaded. This *will not work* with suid binaries as it opens
    # a massive security hole

    CURRENT_WORLD_LIB=${CURRENT_WORLD_ROOT}/install/lib
    if [ -d "$CURRENT_WORLD_LIB" ]
    then
	echo "Setting CURRENT_WORLD_LIB=$CURRENT_WORLD_LIB"
	export CURRENT_WORLD_LIB
	export LD_LIBRARY_PATH=$CURRENT_WORLD_LIB:$ORIG_LD_PATH
    else
	echo "No directory at $CURRENT_WORLD_LIB, not tweaking LD_LIBRARY_PATH"
	CURRENT_WORLD_LIB=$OLD_WORLD_LIB
    fi
}


#
# Bash version comparison routines
# from: http://stackoverflow.com/questions/4023830/bash-how-compare-two-strings-in-version-format
#
vercomp () {
    if [[ $1 == $2 ]]
    then
        return 0
    fi
    local IFS=.
    local i ver1=($1) ver2=($2)
    # fill empty fields in ver1 with zeros
    for ((i=${#ver1[@]}; i<${#ver2[@]}; i++))
    do
        ver1[i]=0
    done
    for ((i=0; i<${#ver1[@]}; i++))
    do
        if [[ -z ${ver2[i]} ]]
        then
            # fill empty fields in ver2 with zeros
            ver2[i]=0
        fi
        if ((10#${ver1[i]} > 10#${ver2[i]}))
        then
            return 1
        fi
        if ((10#${ver1[i]} < 10#${ver2[i]}))
        then
            return 2
        fi
    done
    return 0
}

#
# Unlike switch_world this assumes you want to permanently add something
# to your search paths. It's also a lot quieter about it.
#
function add_to_world
{
    if [ "$1" ]
    then
	if [ "$1" = "." ]
	then
	    CURRENT_WORLD_ROOT=`pwd`
	else
	    CURRENT_WORLD_ROOT=`realpath $1`
	fi
    else
	CURRENT_WORLD_ROOT=`pwd`
    fi

    if [ -d ${CURRENT_WORLD_ROOT}/install ]
    then
        # Check the paths are valid
	CURRENT_WORLD_BIN=${CURRENT_WORLD_ROOT}/install/bin
	if [ -d "$CURRENT_WORLD_BIN" ]
	then
	    export PATH=$CURRENT_WORLD_BIN:$PATH
	    RET=0
	fi

        # This *will not work* with suid binaries as it would
	# open a massive security hole.

	CURRENT_WORLD_LIB=${CURRENT_WORLD_ROOT}/install/lib
	if [ -d "$CURRENT_WORLD_LIB" ]
	then
	    export LD_LIBRARY_PATH=$CURRENT_WORLD_LIB:$LD_LIBRARY_PATH
	    RET=0
	fi
    else
        echo "Just adding $CURRENT_WORLD_ROOT to PATH"
        export PATH=$CURRENT_WORLD_ROOT:$PATH
	RET=0
    fi

    return $RET
}

alias sw="switch_world"
alias aw="add_to_world"

#
# surfraw, command line browser control
# http://surfraw.alioth.debian.org/
#
SURFRAW=$(find_alternatives "surfraw")
if [[ -f $SURFRAW ]]; then
    alias wiki="$SURFRAW wikipedia "
    alias google="$SURFRAW google "
    alias imdb="$SURFRAW imdb "
    alias code="$SURFRAW codesearch"
    alias jspcode="$SURFRAW codesearch lang:jsp"
    alias javacode="$SURFRAW codesearch lang:java"
    alias pycode="$SURFRAW codesearch lang:python"
fi

########################
# Miscelaneous Stuff
########################
# I want core-dumps dammit
ulimit -S -c unlimited


# Helper function to load extra bits of profile that
# are optional depending on the environment.
LOADED_MODULES=""
function load_extra_module()
{
    module=$1
    shift

    find_exes=$(find_alternatives $*)
    module_path=${HOME}/.bash_${module}
    if [[ -f $find_exes && -f $module_path ]]; then
        source $module_path
        LOADED_MODULES="$LOADED_MODULES $module"
    fi
}

# If invoked as /bin/sh let's assume a minimal environment
if [ "$SHELL" == "/bin/sh" ]; then
    echo "Executing $SHELL under minmal environment"
else
    load_extra_module ps1 true
    load_extra_module tmux tmux
    load_extra_module emacs emacs
    load_extra_module git git
    load_extra_module apt apt-get
    load_extra_module kvm kvm
    load_extra_module keys ssh-agent gpg-agent keychain
    load_extra_module screen screen
    load_extra_module valgrind valgrind
    load_extra_module bitbake bitbake
    load_extra_module ccache ccache

    # Gentoo is special...
    if [[ `whoami` != "root" ]]; then
        load_extra_module gentoo emerge
    else
        unset CFLAGS
    fi

    load_extra_module `hostname` true
    load_extra_module devqemu true
    
    load_extra_module user true
    load_extra_module local true
    echo "Loaded$LOADED_MODULES"
fi

# Finally clean PATH (http://unix.stackexchange.com/questions/14895/duplicate-entries-in-path-a-problem)
PATH=$(echo "$PATH" | awk -v RS=':' -v ORS=":" '!a[$1]++{if (NR > 1) printf ORS; printf $a[$1]}')

# Alias for reloading
alias .profile=". ~/.bash_profile"
