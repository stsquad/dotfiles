#!/bin/bash
#
# Alex's .bashrc_keys
#
# Generic handling for all keys, possibly using keychain if we have it.
#

KEYCHAIN=$(find_alternatives keychain)
KEYSMSG=""

if [[ -z "$SSH_AUTH_SOCK" || ! -S "$SSH_AUTH_SOCK" ]]; then
    # If we are a login shell force flushing of credentials
    shopt -q login_shell && KEY_OPTS="--clear" || KEY_OPTS="-Q"

    if [[ -x ${KEYCHAIN} ]]; then
        eval `keychain -q ${KEY_OPTS} --eval`
	KEYSMSG="Using keychain ("
 	if [[ "${KEY_OPTS}" == "--clear" ]]; then
	    KEYSMSG+=" flushed "
    	fi
        if [[ -S ${SSH_AUTH_SOCK} ]]; then
	    KEYSMSG+=" ssh "
        fi
        if [[ "${GPG_AGENT_INFO}" ]]; then
	    KEYSMSG+=" gpg "
        fi
        KEYSMSG+=")"
    else
        if test -f $HOME/.gpg-agent-info && kill -0 `cut -d: -f 2 $HOME/.gpg-agent-info` 2>/dev/null; then
	    GPG_MSG="exisiting agent"
        else
	    gpg-agent --daemon --write-env-file &> /dev/null
	    GPG_MSG="new agent"
        fi

        # Setup environment variables either way
        source $HOME/.gpg-agent-info
        export GPG_AGENT_INFO

        # Ensure prompts come to the correct TTY
        GPG_TTY=`tty`
        export GPG_TTY

        KEYSMSG="$GPG_MSG on $GPG_TTY"
    fi
else
    KEYSMSG="existing ssh"
    if [[ -x ${KEYCHAIN} ]]; then
        eval `keychain -q ${KEY_OPTS} --agents gpg --eval`
        if [[ "${GPG_AGENT_INFO}" ]]; then
	    KEYSMSG+=" keychain gpg"
        fi
    fi
fi

#
# When I log on remotely I only have console mode and as such I need to reset
# gpg-agent so it won't leave passphrase prompts on the X session. The killalls
# unwedge any gpg passphrase requests that might be running before reloading.
#
function reset_gpg_agent
{
    if [[ -x ${KEYCHAIN} ]]; then
        keychain --agents gpg --stop all
        killall -9 gpg2 pinentry 2> /dev/null
        sleep 1
        killall -9 gpg2 pinentry 2> /dev/null
        . ~/.bash_keys
    fi
}

alias .keys=". ~/.bash_keys"
echo "loading .bash_keys ($KEYSMSG)"

